/* tslint:disable */
/* eslint-disable */
/**
 * server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DeleteRecordRq
 */
export interface DeleteRecordRq {
    /**
     * 
     * @type {number}
     * @memberof DeleteRecordRq
     */
    'recordId'?: number;
}
/**
 * 
 * @export
 * @interface Employer
 */
export interface Employer {
    /**
     * 
     * @type {string}
     * @memberof Employer
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employer
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employer
     */
    'email'?: string;
    /**
     * 
     * @type {Mode}
     * @memberof Employer
     */
    'mode'?: Mode;
}


/**
 * 
 * @export
 * @interface GetEmployerRq
 */
export interface GetEmployerRq {
    /**
     * 
     * @type {string}
     * @memberof GetEmployerRq
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface GetEmployerRs
 */
export interface GetEmployerRs {
    /**
     * 
     * @type {Array<Employer>}
     * @memberof GetEmployerRs
     */
    'employers'?: Array<Employer>;
}
/**
 * 
 * @export
 * @interface GetOTPRq
 */
export interface GetOTPRq {
    /**
     * 
     * @type {string}
     * @memberof GetOTPRq
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface GetOTPRs
 */
export interface GetOTPRs {
    /**
     * 
     * @type {number}
     * @memberof GetOTPRs
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetOTPRs
     */
    'otp': string;
    /**
     * 
     * @type {string}
     * @memberof GetOTPRs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GetOTPRs
     */
    'createDate': string;
}
/**
 * 
 * @export
 * @interface GetRecordByPeriodRq
 */
export interface GetRecordByPeriodRq {
    /**
     * 
     * @type {string}
     * @memberof GetRecordByPeriodRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecordByPeriodRq
     */
    'serviceProviderEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetRecordByPeriodRq
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRecordByPeriodRq
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface GetRecordChangeRs
 */
export interface GetRecordChangeRs {
    /**
     * 
     * @type {Array<RecordChange>}
     * @memberof GetRecordChangeRs
     */
    'records'?: Array<RecordChange>;
}
/**
 * 
 * @export
 * @interface GetRecordRq
 */
export interface GetRecordRq {
    /**
     * 
     * @type {string}
     * @memberof GetRecordRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecordRq
     */
    'serviceProviderEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetRecordRs
 */
export interface GetRecordRs {
    /**
     * 
     * @type {Array<Record>}
     * @memberof GetRecordRs
     */
    'records'?: Array<Record>;
}
/**
 * 
 * @export
 * @interface GetRequestByEmailRq
 */
export interface GetRequestByEmailRq {
    /**
     * 
     * @type {string}
     * @memberof GetRequestByEmailRq
     */
    'senderEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestByEmailRq
     */
    'receiverEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetRequestByStatusRq
 */
export interface GetRequestByStatusRq {
    /**
     * 
     * @type {string}
     * @memberof GetRequestByStatusRq
     */
    'receiverEmail'?: string;
    /**
     * 
     * @type {RequestStatus}
     * @memberof GetRequestByStatusRq
     */
    'status'?: RequestStatus;
}


/**
 * 
 * @export
 * @interface GetRequestRq
 */
export interface GetRequestRq {
    /**
     * 
     * @type {string}
     * @memberof GetRequestRq
     */
    'receiverEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetRequestRs
 */
export interface GetRequestRs {
    /**
     * 
     * @type {Array<RequestRawDB>}
     * @memberof GetRequestRs
     */
    'requests'?: Array<RequestRawDB>;
}
/**
 * 
 * @export
 * @interface GetRequestRsMini
 */
export interface GetRequestRsMini {
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'rate'?: string;
    /**
     * 
     * @type {RateType}
     * @memberof GetRequestRsMini
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'day'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'endTime'?: string;
    /**
     * 
     * @type {Mode}
     * @memberof GetRequestRsMini
     */
    'allowEdit'?: Mode;
    /**
     * 
     * @type {any}
     * @memberof GetRequestRsMini
     */
    'schedules'?: any;
    /**
     * 
     * @type {string}
     * @memberof GetRequestRsMini
     */
    'requestDate'?: string;
}


/**
 * 
 * @export
 * @interface GetServiceProviderRq
 */
export interface GetServiceProviderRq {
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRq
     */
    'employerEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetServiceProviderRsMini
 */
export interface GetServiceProviderRsMini {
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRsMini
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRsMini
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRsMini
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRsMini
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceProviderRsMini
     */
    'rate'?: string;
    /**
     * 
     * @type {RateType}
     * @memberof GetServiceProviderRsMini
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {Mode}
     * @memberof GetServiceProviderRsMini
     */
    'allowEdit'?: Mode;
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof GetServiceProviderRsMini
     */
    'schedules': Array<UserSchedule>;
}


/**
 * 
 * @export
 * @interface GetUserRq
 */
export interface GetUserRq {
    /**
     * 
     * @type {string}
     * @memberof GetUserRq
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface GetUserRs
 */
export interface GetUserRs {
    /**
     * 
     * @type {string}
     * @memberof GetUserRs
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRs
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRs
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GetUserScheduleRq
 */
export interface GetUserScheduleRq {
    /**
     * 
     * @type {string}
     * @memberof GetUserScheduleRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserScheduleRq
     */
    'serviceProviderEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetUserScheduleRs
 */
export interface GetUserScheduleRs {
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof GetUserScheduleRs
     */
    'rows'?: Array<UserSchedule>;
}
/**
 * 
 * @export
 * @interface GetUserTransactionRq
 */
export interface GetUserTransactionRq {
    /**
     * 
     * @type {string}
     * @memberof GetUserTransactionRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserTransactionRq
     */
    'serviceProviderEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetUserTransactionRs
 */
export interface GetUserTransactionRs {
    /**
     * 
     * @type {number}
     * @memberof GetUserTransactionRs
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUserTransactionRs
     */
    'rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserTransactionRs
     */
    'rateType'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetUserTransactionRs
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Mode}
     * @memberof GetUserTransactionRs
     */
    'mode'?: Mode;
}


/**
 * 
 * @export
 * @enum {number}
 */

export const Mode = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type Mode = typeof Mode[keyof typeof Mode];


/**
 * 
 * @export
 * @enum {string}
 */

export const RateType = {
    Hourly: 'hourly',
    Daily: 'daily'
} as const;

export type RateType = typeof RateType[keyof typeof RateType];


/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {number}
     * @memberof Record
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'epoch_start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'epoch_end_time'?: string | null;
}
/**
 * 
 * @export
 * @interface RecordChange
 */
export interface RecordChange {
    /**
     * 
     * @type {string}
     * @memberof RecordChange
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordChange
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordChange
     */
    'changedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordChange
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface RequestRawDB
 */
export interface RequestRawDB {
    /**
     * 
     * @type {number}
     * @memberof RequestRawDB
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'senderFirstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'senderLastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'senderEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'receiverEmail'?: string;
    /**
     * 
     * @type {RequestStatus}
     * @memberof RequestRawDB
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'rate'?: string;
    /**
     * 
     * @type {RateType}
     * @memberof RequestRawDB
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'requestDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'day'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRawDB
     */
    'endTime'?: string;
    /**
     * 
     * @type {Mode}
     * @memberof RequestRawDB
     */
    'allowEdit'?: Mode;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RequestStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING'
} as const;

export type RequestStatus = typeof RequestStatus[keyof typeof RequestStatus];


/**
 * 
 * @export
 * @interface ResetPasswordRq
 */
export interface ResetPasswordRq {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRq
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRq
     */
    'newPassword'?: string;
}
/**
 * 
 * @export
 * @interface ServiceProviderMiniRs
 */
export interface ServiceProviderMiniRs {
    /**
     * 
     * @type {GetUserRs}
     * @memberof ServiceProviderMiniRs
     */
    'serviceProviderUser'?: GetUserRs;
}
/**
 * 
 * @export
 * @interface SetOTPRq
 */
export interface SetOTPRq {
    /**
     * 
     * @type {string}
     * @memberof SetOTPRq
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetOTPRq
     */
    'otp'?: string;
}
/**
 * 
 * @export
 * @interface SetRecordRq
 */
export interface SetRecordRq {
    /**
     * 
     * @type {number}
     * @memberof SetRecordRq
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SetRecordRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetRecordRq
     */
    'serviceProviderEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetRecordRq
     */
    'recordTime'?: number;
    /**
     * 
     * @type {TimeType}
     * @memberof SetRecordRq
     */
    'type'?: TimeType;
}


/**
 * 
 * @export
 * @interface SetRequestRq
 */
export interface SetRequestRq {
    /**
     * 
     * @type {string}
     * @memberof SetRequestRq
     */
    'senderEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetRequestRq
     */
    'receiverEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetRequestRq
     */
    'rate'?: number;
    /**
     * 
     * @type {RateType}
     * @memberof SetRequestRq
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof SetRequestRq
     */
    'schedules'?: Array<UserSchedule>;
    /**
     * 
     * @type {Mode}
     * @memberof SetRequestRq
     */
    'mode'?: Mode;
}


/**
 * 
 * @export
 * @interface SetUserRq
 */
export interface SetUserRq {
    /**
     * 
     * @type {string}
     * @memberof SetUserRq
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserRq
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserRq
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserRq
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface SetUserScheduleRq
 */
export interface SetUserScheduleRq {
    /**
     * 
     * @type {string}
     * @memberof SetUserScheduleRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserScheduleRq
     */
    'serviceProviderEmail'?: string;
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof SetUserScheduleRq
     */
    'schedules'?: Array<UserSchedule>;
}
/**
 * 
 * @export
 * @interface SetUserTransactionRq
 */
export interface SetUserTransactionRq {
    /**
     * 
     * @type {string}
     * @memberof SetUserTransactionRq
     */
    'rate'?: string;
    /**
     * 
     * @type {RateType}
     * @memberof SetUserTransactionRq
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {string}
     * @memberof SetUserTransactionRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserTransactionRq
     */
    'serviceProviderEmail'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof SetUserTransactionRq
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Mode}
     * @memberof SetUserTransactionRq
     */
    'mode'?: Mode;
}


/**
 * 
 * @export
 * @interface SignInUser200Response
 */
export interface SignInUser200Response {
    /**
     * 
     * @type {GetUserRs}
     * @memberof SignInUser200Response
     */
    'user': GetUserRs;
    /**
     * 
     * @type {string}
     * @memberof SignInUser200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SignInUserRq
 */
export interface SignInUserRq {
    /**
     * 
     * @type {string}
     * @memberof SignInUserRq
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInUserRq
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeType = {
    Start: 'start',
    End: 'end'
} as const;

export type TimeType = typeof TimeType[keyof typeof TimeType];


/**
 * 
 * @export
 * @interface UpdateRecordRq
 */
export interface UpdateRecordRq {
    /**
     * 
     * @type {number}
     * @memberof UpdateRecordRq
     */
    'recordId'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateRecordRq
     */
    'recordTime'?: number;
    /**
     * 
     * @type {TimeType}
     * @memberof UpdateRecordRq
     */
    'type'?: TimeType;
}


/**
 * 
 * @export
 * @interface UpdateRequestRq
 */
export interface UpdateRequestRq {
    /**
     * 
     * @type {string}
     * @memberof UpdateRequestRq
     */
    'senderEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequestRq
     */
    'receiverEmail'?: string;
    /**
     * 
     * @type {RequestStatus}
     * @memberof UpdateRequestRq
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequestRq
     */
    'rate'?: string;
    /**
     * 
     * @type {RateType}
     * @memberof UpdateRequestRq
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof UpdateRequestRq
     */
    'schedules'?: Array<UserSchedule>;
    /**
     * 
     * @type {Mode}
     * @memberof UpdateRequestRq
     */
    'mode'?: Mode;
}


/**
 * 
 * @export
 * @interface UpdateServiceProviderRq
 */
export interface UpdateServiceProviderRq {
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceProviderRq
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceProviderRq
     */
    'serviceProviderEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateServiceProviderRq
     */
    'rate'?: number;
    /**
     * 
     * @type {RateType}
     * @memberof UpdateServiceProviderRq
     */
    'rateType'?: RateType;
    /**
     * 
     * @type {Array<UserSchedule>}
     * @memberof UpdateServiceProviderRq
     */
    'schedule'?: Array<UserSchedule>;
}


/**
 * 
 * @export
 * @interface UserSchedule
 */
export interface UserSchedule {
    /**
     * 
     * @type {number}
     * @memberof UserSchedule
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSchedule
     */
    'day'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSchedule
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeleteRecordRq} deleteRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecord: async (deleteRecordRq: DeleteRecordRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRecordRq' is not null or undefined
            assertParamExists('deleteRecord', 'deleteRecordRq', deleteRecordRq)
            const localVarPath = `/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRecordRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployer: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOTP: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord: async (employerEmail?: string, serviceProviderEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }

            if (serviceProviderEmail !== undefined) {
                localVarQueryParameter['serviceProviderEmail'] = serviceProviderEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordByPeriod: async (employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/record/period`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }

            if (serviceProviderEmail !== undefined) {
                localVarQueryParameter['serviceProviderEmail'] = serviceProviderEmail;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordChanges: async (employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/record/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }

            if (serviceProviderEmail !== undefined) {
                localVarQueryParameter['serviceProviderEmail'] = serviceProviderEmail;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestByEmail: async (senderEmail?: string, receiverEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/request/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (senderEmail !== undefined) {
                localVarQueryParameter['senderEmail'] = senderEmail;
            }

            if (receiverEmail !== undefined) {
                localVarQueryParameter['receiverEmail'] = receiverEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequests: async (receiverEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (receiverEmail !== undefined) {
                localVarQueryParameter['receiverEmail'] = receiverEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {RequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsByStatus: async (receiverEmail?: string, status?: RequestStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/request/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (receiverEmail !== undefined) {
                localVarQueryParameter['receiverEmail'] = receiverEmail;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (employerEmail?: string, serviceProviderEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }

            if (serviceProviderEmail !== undefined) {
                localVarQueryParameter['serviceProviderEmail'] = serviceProviderEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceProvider: async (employerEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/serviceProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransaction: async (employerEmail?: string, serviceProviderEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (employerEmail !== undefined) {
                localVarQueryParameter['employerEmail'] = employerEmail;
            }

            if (serviceProviderEmail !== undefined) {
                localVarQueryParameter['serviceProviderEmail'] = serviceProviderEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRequestValid: async (senderEmail?: string, receiverEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/request/eligible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (senderEmail !== undefined) {
                localVarQueryParameter['senderEmail'] = senderEmail;
            }

            if (receiverEmail !== undefined) {
                localVarQueryParameter['receiverEmail'] = receiverEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordRq} resetPasswordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRq: ResetPasswordRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRq' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRq', resetPasswordRq)
            const localVarPath = `/user/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOTP: async (setOTPRq: SetOTPRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setOTPRq' is not null or undefined
            assertParamExists('setOTP', 'setOTPRq', setOTPRq)
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setOTPRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetRecordRq} setRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecord: async (setRecordRq: SetRecordRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setRecordRq' is not null or undefined
            assertParamExists('setRecord', 'setRecordRq', setRecordRq)
            const localVarPath = `/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRecordRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetRequestRq} setRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRequest: async (setRequestRq: SetRequestRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setRequestRq' is not null or undefined
            assertParamExists('setRequest', 'setRequestRq', setRequestRq)
            const localVarPath = `/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRequestRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserScheduleRq} setUserScheduleRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchedule: async (setUserScheduleRq: SetUserScheduleRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserScheduleRq' is not null or undefined
            assertParamExists('setSchedule', 'setUserScheduleRq', setUserScheduleRq)
            const localVarPath = `/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserScheduleRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUser: async (setUserRq: SetUserRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserRq' is not null or undefined
            assertParamExists('setUser', 'setUserRq', setUserRq)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserTransactionRq} setUserTransactionRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserTransaction: async (setUserTransactionRq: SetUserTransactionRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserTransactionRq' is not null or undefined
            assertParamExists('setUserTransaction', 'setUserTransactionRq', setUserTransactionRq)
            const localVarPath = `/userTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserTransactionRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInUserRq} signInUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUser: async (signInUserRq: SignInUserRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInUserRq' is not null or undefined
            assertParamExists('signInUser', 'signInUserRq', signInUserRq)
            const localVarPath = `/user/signIn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInUserRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUser: async (setUserRq: SetUserRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserRq' is not null or undefined
            assertParamExists('signUpUser', 'setUserRq', setUserRq)
            const localVarPath = `/user/signUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRecordRq} updateRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecord: async (updateRecordRq: UpdateRecordRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRecordRq' is not null or undefined
            assertParamExists('updateRecord', 'updateRecordRq', updateRecordRq)
            const localVarPath = `/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecordRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRequestRq} updateRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequest: async (updateRequestRq: UpdateRequestRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRequestRq' is not null or undefined
            assertParamExists('updateRequest', 'updateRequestRq', updateRequestRq)
            const localVarPath = `/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequestRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateServiceProviderRq} updateServiceProviderRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceProvider: async (updateServiceProviderRq: UpdateServiceProviderRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateServiceProviderRq' is not null or undefined
            assertParamExists('updateServiceProvider', 'updateServiceProviderRq', updateServiceProviderRq)
            const localVarPath = `/serviceProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateServiceProviderRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/verifyEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOTP: async (setOTPRq: SetOTPRq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setOTPRq' is not null or undefined
            assertParamExists('verifyOTP', 'setOTPRq', setOTPRq)
            const localVarPath = `/otp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setOTPRq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeleteRecordRq} deleteRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecord(deleteRecordRq: DeleteRecordRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecord(deleteRecordRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployer(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmployerRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployer(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEmployer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOTP(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOTPRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOTP(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecord(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecordRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(employerEmail, serviceProviderEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordByPeriod(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecordRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordByPeriod(employerEmail, serviceProviderEmail, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecordByPeriod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordChanges(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecordChangeRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordChanges(employerEmail, serviceProviderEmail, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecordChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestByEmail(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRequestRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestByEmail(senderEmail, receiverEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRequestByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequests(receiverEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRequestRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequests(receiverEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {RequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestsByStatus(receiverEmail?: string, status?: RequestStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRequestRsMini>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestsByStatus(receiverEmail, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRequestsByStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserScheduleRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(employerEmail, serviceProviderEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceProvider(employerEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetServiceProviderRsMini>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceProvider(employerEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getServiceProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransaction(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactionRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransaction(employerEmail, serviceProviderEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRequestValid(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderMiniRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRequestValid(senderEmail, receiverEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isRequestValid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResetPasswordRq} resetPasswordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRq: ResetPasswordRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOTP(setOTPRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetRecordRq} setRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRecord(setRecordRq: SetRecordRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecordRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRecord(setRecordRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetRequestRq} setRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRequest(setRequestRq: SetRequestRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRequest(setRequestRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetUserScheduleRq} setUserScheduleRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSchedule(setUserScheduleRq: SetUserScheduleRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSchedule(setUserScheduleRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUser(setUserRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetUserTransactionRq} setUserTransactionRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserTransaction(setUserTransactionRq: SetUserTransactionRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserTransaction(setUserTransactionRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.setUserTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInUserRq} signInUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInUser(signInUserRq: SignInUserRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signInUser(signInUserRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signInUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUpUser(setUserRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signUpUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateRecordRq} updateRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecord(updateRecordRq: UpdateRecordRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecordRs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecord(updateRecordRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateRequestRq} updateRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRequest(updateRequestRq: UpdateRequestRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRequest(updateRequestRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateServiceProviderRq} updateServiceProviderRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceProvider(updateServiceProviderRq: UpdateServiceProviderRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceProvider(updateServiceProviderRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateServiceProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOTP(setOTPRq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verifyOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {DeleteRecordRq} deleteRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecord(deleteRecordRq: DeleteRecordRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecord(deleteRecordRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployer(email?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEmployerRs> {
            return localVarFp.getEmployer(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOTP(email?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOTPRs> {
            return localVarFp.getOTP(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRecordRs> {
            return localVarFp.getRecord(employerEmail, serviceProviderEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordByPeriod(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRecordRs> {
            return localVarFp.getRecordByPeriod(employerEmail, serviceProviderEmail, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordChanges(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRecordChangeRs> {
            return localVarFp.getRecordChanges(employerEmail, serviceProviderEmail, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestByEmail(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRequestRs> {
            return localVarFp.getRequestByEmail(senderEmail, receiverEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequests(receiverEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRequestRs> {
            return localVarFp.getRequests(receiverEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [receiverEmail] 
         * @param {RequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsByStatus(receiverEmail?: string, status?: RequestStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRequestRsMini>> {
            return localVarFp.getRequestsByStatus(receiverEmail, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserScheduleRs> {
            return localVarFp.getSchedule(employerEmail, serviceProviderEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceProvider(employerEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetServiceProviderRsMini>> {
            return localVarFp.getServiceProvider(employerEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(email?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserRs> {
            return localVarFp.getUser(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [employerEmail] 
         * @param {string} [serviceProviderEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransaction(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserTransactionRs> {
            return localVarFp.getUserTransaction(employerEmail, serviceProviderEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [senderEmail] 
         * @param {string} [receiverEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRequestValid(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceProviderMiniRs> {
            return localVarFp.isRequestValid(senderEmail, receiverEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPasswordRq} resetPasswordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRq: ResetPasswordRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setOTP(setOTPRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetRecordRq} setRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecord(setRecordRq: SetRecordRq, options?: RawAxiosRequestConfig): AxiosPromise<GetRecordRs> {
            return localVarFp.setRecord(setRecordRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetRequestRq} setRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRequest(setRequestRq: SetRequestRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setRequest(setRequestRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserScheduleRq} setUserScheduleRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchedule(setUserScheduleRq: SetUserScheduleRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setSchedule(setUserScheduleRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUser(setUserRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserTransactionRq} setUserTransactionRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserTransaction(setUserTransactionRq: SetUserTransactionRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUserTransaction(setUserTransactionRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInUserRq} signInUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUser(signInUserRq: SignInUserRq, options?: RawAxiosRequestConfig): AxiosPromise<SignInUser200Response> {
            return localVarFp.signInUser(signInUserRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserRq} setUserRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.signUpUser(setUserRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateRecordRq} updateRecordRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecord(updateRecordRq: UpdateRecordRq, options?: RawAxiosRequestConfig): AxiosPromise<GetRecordRs> {
            return localVarFp.updateRecord(updateRecordRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateRequestRq} updateRequestRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequest(updateRequestRq: UpdateRequestRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRequest(updateRequestRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateServiceProviderRq} updateServiceProviderRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceProvider(updateServiceProviderRq: UpdateServiceProviderRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateServiceProvider(updateServiceProviderRq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(email?: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.verifyEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetOTPRq} setOTPRq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifyOTP(setOTPRq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {DeleteRecordRq} deleteRecordRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteRecord(deleteRecordRq: DeleteRecordRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRecord(deleteRecordRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEmployer(email?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEmployer(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOTP(email?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOTP(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {string} [serviceProviderEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecord(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecord(employerEmail, serviceProviderEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {string} [serviceProviderEmail] 
     * @param {number} [from] 
     * @param {number} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecordByPeriod(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecordByPeriod(employerEmail, serviceProviderEmail, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {string} [serviceProviderEmail] 
     * @param {number} [from] 
     * @param {number} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecordChanges(employerEmail?: string, serviceProviderEmail?: string, from?: number, to?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecordChanges(employerEmail, serviceProviderEmail, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [senderEmail] 
     * @param {string} [receiverEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRequestByEmail(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRequestByEmail(senderEmail, receiverEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [receiverEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRequests(receiverEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRequests(receiverEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [receiverEmail] 
     * @param {RequestStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRequestsByStatus(receiverEmail?: string, status?: RequestStatus, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRequestsByStatus(receiverEmail, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {string} [serviceProviderEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSchedule(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSchedule(employerEmail, serviceProviderEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceProvider(employerEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceProvider(employerEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUser(email?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUser(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [employerEmail] 
     * @param {string} [serviceProviderEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserTransaction(employerEmail?: string, serviceProviderEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserTransaction(employerEmail, serviceProviderEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [senderEmail] 
     * @param {string} [receiverEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isRequestValid(senderEmail?: string, receiverEmail?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isRequestValid(senderEmail, receiverEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPasswordRq} resetPasswordRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPassword(resetPasswordRq: ResetPasswordRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(resetPasswordRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetOTPRq} setOTPRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setOTP(setOTPRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetRecordRq} setRecordRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setRecord(setRecordRq: SetRecordRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setRecord(setRecordRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetRequestRq} setRequestRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setRequest(setRequestRq: SetRequestRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setRequest(setRequestRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserScheduleRq} setUserScheduleRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSchedule(setUserScheduleRq: SetUserScheduleRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setSchedule(setUserScheduleRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserRq} setUserRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUser(setUserRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserTransactionRq} setUserTransactionRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setUserTransaction(setUserTransactionRq: SetUserTransactionRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUserTransaction(setUserTransactionRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInUserRq} signInUserRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signInUser(signInUserRq: SignInUserRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signInUser(signInUserRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserRq} setUserRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signUpUser(setUserRq: SetUserRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signUpUser(setUserRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateRecordRq} updateRecordRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateRecord(updateRecordRq: UpdateRecordRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateRecord(updateRecordRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateRequestRq} updateRequestRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateRequest(updateRequestRq: UpdateRequestRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateRequest(updateRequestRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateServiceProviderRq} updateServiceProviderRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateServiceProvider(updateServiceProviderRq: UpdateServiceProviderRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateServiceProvider(updateServiceProviderRq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyEmail(email?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifyEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetOTPRq} setOTPRq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyOTP(setOTPRq: SetOTPRq, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifyOTP(setOTPRq, options).then((request) => request(this.axios, this.basePath));
    }
}



